import datetime
import abc
from functools import wraps
from django.utils.crypto import constant_time_compare, salted_hmac
from django.http import HttpResponseGone, Http404
from django.utils.http import base36_to_int, int_to_base36
from django.utils.translation import ugettext_lazy as _
from django.shortcuts import render, redirect
from django.conf import settings
from django.views import View
from django.views.generic.detail import SingleObjectMixin


class TokenValidator(abc.ABC):
    """Base class for all token validators."""

    VALID_TOKEN = 1
    MALFORMED_TOKEN = 2
    EXPIRED_TOKEN = 3

    @abc.abstractmethod
    def parse_token(self, token):
        """Parse a token.

        This method should return a tuple containing one of 
        :const:`TokenValidator.VALID_TOKEN`, 
        :const:`TokenValidator.MALFORMED_TOKEN` or 
        :const:`TokenValidator.EXPIRED_TOKEN` and a :class:`datetime.datetime`
        object specifying the token's expiration timestamp.
        The expiration time may be ``None`` in all cases.

        :param str token: a token string
        :returns: the parse result and the token's expiration time.
        :rtype: int, datetime.datetime
        """
        raise NotImplementedError(
            'TokenValidator subclasses must implement `parse_token`'
        )

    def validate_token(self, token):
        """Validate a token.

        This is a thin wrapper around :meth:`parse_token`.  
        Returns ``True`` if and only if the parse result is 
        :const:`TokenValidator.VALID_TOKEN`.

        :param str token: a token string
        :rtype: bool
        """
        response, _ = self.parse_token(token)
        return response == TokenValidator.VALID_TOKEN


class ObjectTokenValidator(TokenValidator, abc.ABC):
    """Token validator that looks up a token as an attribute on an object."""

    token_attribute_name = 'token'
    """
    Name of the token attribute.
    """

    is_binary_field = True
    """
    Controls whether or not the token field is binary.
    If so, :meth:`str.hex` is called first.
    """

    @abc.abstractmethod
    def get_object(self):
        """
        Function called to retrieve the object on which the token lives.
        Must be implemented by subclasses.
        """
        raise NotImplementedError(
            'Subclasses of ObjectTokenValidator should implement get_object'
        )

    # noinspection PyMethodMayBeStatic
    def object_expired(self):
        """
        If this function returns ``True``, the token will be considered stale.
        """
        return False

    def parse_token(self, token):
        """
        Returns :const:`TokenValidator.MALFORMED_TOKEN` if ``token`` does not
        match the token stored on the object.
        Otherwise, if :meth:`object_expired` returns ``True``, 
        :const:`TokenValidator.EXPIRED_TOKEN` is returned.
        Barring either of these, the method returns 
        :const:`TokenValidator.VALID_TOKEN`.
        """

        real_token = getattr(self.get_object(), self.token_attribute_name)
        if self.is_binary_field:
            real_token = real_token.hex()
        if token != real_token:
            return TokenValidator.MALFORMED_TOKEN, None
        elif self.object_expired():
            return TokenValidator.EXPIRED_TOKEN, None
        else:
            return TokenValidator.VALID_TOKEN, None


class TimeBasedTokenGenerator:
    """
    Inspired by :class:`django.contrib.auth.tokens.PasswordResetTokenGenerator`.
    Instances of this class generate tokens that expire after a given time.
    Ultimately relies on :func:`django.utils.crypto.salted_hmac`.

    The default implementation uses a timespan in hours.
    This can be changed by overriding :meth:`ts_from_delta` and 
    :meth:`ts_to_delta`. The default datetime epoch is set to January 1st 2001,
    which is reasonable for tokens with a lifespan expressed in hours.

    Subclasses of this class automatically get a ``validator`` class attribute 
    that derives a compatible subclass of TimeBasedTokenValidator.

    Instantiating this class without subclassing it is discouraged, since 
    the salt is derived from the subclass name, so tokens generated by the
    same class for different purposes would be interchangeable.
    This is usually not what you want.

    :ivar datetime.datetime origin: the datetime epoch used
    :ivar str secret: the secret passed to :func:`salted_hmac`.
    :ivar int lifespan: the token's lifespan (see :meth:`get_lifespan`)
    """

    origin = datetime.datetime.combine(
        datetime.date(2001, 1, 1), datetime.datetime.min.time()
    )

    secret = settings.SECRET_KEY
    lifespan = 0
    validator = None

    def __new__(cls, *args, **kwargs):
        if cls is TimeBasedTokenGenerator:
            raise TypeError(
                'TimeBasedTokenGenerator must be subclassed'
            )
        # if __new__ is called with arguments from a subclass that does
        # not explicitly override it, we'll get those args before
        # the subclass's __init__ method can consume them.
        # Since object() does not take any arguments, we have 
        # to discard them explicitly
        return super().__new__(cls)

    # TODO: add validator_base kwarg example
    def __init_subclass__(cls, validator_base=None):
        # As opposed to hasattr(), this ensures that a subclass can only
        # override our inheritance magic by explicitly declaring
        # the relevant attribute
        if 'key_salt' not in cls.__dict__:
            cls.key_salt = cls.__name__

        if 'validator' not in cls.__dict__:
            if validator_base is None:
                # see if we can find a validator somewhere 
                # in the superclasses because __init_subclass__
                # kwargs are not inherited
                for parent in cls.__mro__[1:]:
                    if issubclass(parent, TimeBasedTokenValidator):
                        # in this scenario, the generator and validator
                        # are one and the same, so this makes sense
                        # as a default.
                        # We don't even attempt to subclass
                        cls.validator = cls
                        return
                    try:
                        validator_base = parent.validator
                        break
                    except AttributeError:
                        continue
            # if validator_base is still None, we take 
            # the most basic one available
            validator_base = validator_base or TimeBasedTokenValidator
            cls.validator = type(
                'ValidatorFrom' + cls.__name__,
                (validator_base,),
                {'generator_class': cls}
            )

    @classmethod
    def from_view_data(cls, request, view_args=None,
                       view_kwargs=None, view_instance=None):
        try:
            kwargs = cls.get_constructor_kwargs(
                request, view_args, view_kwargs, view_instance
            )
            return cls(**kwargs)
        except TypeError:
            raise TypeError(
                'No suitable constructor found to instantiate '
                'generator from view data.'
            )

    @classmethod
    def get_constructor_kwargs(cls, request, view_args=None,
                               view_kwargs=None, view_instance=None):
        # a more subclassing-friendly approach to from_view_data
        return {}

    def make_token(self):
        """
        :returns: a token and the timestamp when it expires.
        :rtype: str, datetime.datetime
        """
        return self._make_token_with_timestamp(
            self.time_elapsed(self.current_time()), self.get_lifespan()
        ) 

    def bare_token(self):
        """
        :returns: a token without the timestamp when it expires.
        :rtype: str
        """
        return self.make_token()[0]
    
    def extra_hash_data(self):
        """
        Generate extra hash data to pass to :func:`salted_hmac`.
        Default is the empty string.

        :rtype: str
        """
        return ''

    def get_lifespan(self):
        """
        :returns: ``self.lifespan`` by default
        :rtype: int
        """
        return self.lifespan

    def _make_token_with_timestamp(self, timestamp, lifespan):
        ts_b36 = int_to_base36(timestamp)
        token_hash = salted_hmac(
            self.key_salt,
            str(lifespan) + str(timestamp) + str(self.extra_hash_data()),
            secret=self.secret,
        ).hexdigest()[::2]
        token = "%s-%s-%s" % (lifespan, ts_b36, token_hash)
        if lifespan:
            expiry_ts = lifespan + timestamp
            valid_until = self.timestamp_to_datetime(expiry_ts)
            return token, valid_until
        else:
            return token, None

    @classmethod
    def ts_to_delta(cls, ts):
        """
        Convert an integer timespan indication to a :class:`datetime.timedelta`
        object.
        The default implementation assumes the timespan is in hours.

        :param int ts: the timespan indication
        :rtype: datetime.timedelta
        """
        return datetime.timedelta(seconds=ts * 3600)

    @classmethod
    def ts_from_delta(cls, delta):
        """
        Convert a :class:`datetime.timedelta` object to an integer timespan.
        The default implementation assumes the timespan is in hours.

        :param datetime.timedelta delta: the time delta to convert
        :rtype: int
        """
        return delta.days * 24 + delta.seconds // 3600

    def timestamp_to_datetime(self, ts):
        """
        Convert an integer timespan indication to a :class:`datetime.datetime`
        object by adding the result of :meth:`ts_to_delta` to ``self.origin``.

        :param int ts: the timespan indication
        :rtype: datetime.datetime
        """
        return self.origin + self.ts_to_delta(ts)
        
    def time_elapsed(self, dt):
        """
        Convert a :class:`datetime.datetime` object to an integer timespan
        by applying :meth:`ts_from_delta` to the difference of ``dt`` and 
        ``self.origin``.

        :param datetime.datetime dt: the datetime to convert
        :rtype: int
        """
        return self.ts_from_delta(dt - self.origin)

    @classmethod
    def current_time(cls):
        return datetime.datetime.now().replace(
            minute=0, second=0, microsecond=0
        )


class TimeBasedTokenValidator(TokenValidator):
    """
    Validate tokens from a :class:`TimeBasedTokenGenerator`.
    """

    generator = None
     
    def get_generator(self):
        """
        Fetch the generator to obtain tokens from.
        The default implementation requires that either 
        ``self.generator`` or ``self.generator_class``
        be defined.

        If ``self.generator`` is specified, the value of this 
        instance attribute is used.
        If not, this method looks for ``self.generator_class``
        and attempts to call its :func:`from_view_data` method.
        Failing that, the no-arguments constructor is called.

        By default, subclasses of :class:`TimeBasedTokenGenerator`
        make sure that their respective `validator` class attributes
        come with the right fields to make this work out of the box.

        :rtype: TimeBasedTokenGenerator
        """
        try:
            return self.generator 
        except AttributeError:
            return None

    def parse_token(self, token):
        """
        Parse a token according to the semantics of 
        :meth:`TokenValidator.parse_token`.
        """
        if not token:
            return self.MALFORMED_TOKEN, None

        generator = self.get_generator()

        # Parse the token
        try:
            lifespan_str, ts_b36, token_hash = token.split("-")
            lifespan = int(lifespan_str)
        except ValueError:
            return self.MALFORMED_TOKEN, None

        try:
            ts = base36_to_int(ts_b36)
        except ValueError:
            return self.MALFORMED_TOKEN, None

        token_intact = constant_time_compare(
            generator._make_token_with_timestamp(ts, lifespan)[0], token
        )
        if not token_intact:
            return self.MALFORMED_TOKEN, None

        # lifespan = 0 => always valid
        if lifespan:
            cur_ts = generator.time_elapsed(generator.current_time())
            expiry_ts = lifespan + ts
            valid_until = generator.timestamp_to_datetime(expiry_ts)
            if cur_ts < ts or cur_ts > expiry_ts:
                return self.EXPIRED_TOKEN, valid_until 
            return self.VALID_TOKEN, valid_until
        else:
            return self.VALID_TOKEN, None


def _maybe_pass_kwarg(name, pass_kwarg, value, kwargs):
    if pass_kwarg:
        kwargs[name] = value
    else:
        try:
            del kwargs[name]
        except KeyError:
            pass


class RequestTokenValidator(TokenValidator, abc.ABC):
    """
    Eliminate boilerplate for token validation in views.
    """

    pass_token = True
    pass_valid_until = False
    redirect_url = None
    gone_template_name = None
    generator_class = None

    @abc.abstractmethod
    def get_token(self):
        """
        Retrieve the token from request data.
        """
        raise NotImplementedError(
            'Subclasses must implement get_token'
        )

    def handle_token(self, view_func, pass_token=None, redirect_url=None,
                     pass_valid_until=None, gone_template_name=None):
        """
        Return a response based on the token value and view parameters.
        If a valid token is found, the view is executed with the correct
        parameters.
        If either ``redirect_url`` or ``self.redirect_url`` 
        is not ``None``, the response will be a redirect
        no matter where the validation fails.
        These fields may be callables. In this case, they will be called with
        the view parameters.
        Otherwise, we return an appropriate error response.
        """
        redirect_url = redirect_url or self.redirect_url
        gone_template_name = gone_template_name or self.gone_template_name
        if pass_valid_until is None:
            pass_valid_until = self.pass_valid_until
        if pass_token is None:
            pass_token = self.pass_token
        # validate the token
        try:
            token = self.get_token()
            parse_res, valid_until = self.parse_token(token)
        except (KeyError, AttributeError):
            token = valid_until = None
            parse_res = self.MALFORMED_TOKEN

        if parse_res == self.VALID_TOKEN:
            # decide which arguments to pass through or remove
            _maybe_pass_kwarg(
                'valid_until', pass_valid_until, valid_until, self.view_kwargs
            )
            _maybe_pass_kwarg(
                'token', pass_token, token, self.view_kwargs
            )
            return view_func(
                self.request, *self.view_args, **self.view_kwargs
            )
        elif redirect_url is not None:
            if callable(redirect_url):
                redirect_url = redirect_url(self.request)
            return redirect(redirect_url)
        elif parse_res == self.EXPIRED_TOKEN:
            # Return a 410 response
            if gone_template_name is None:
                if valid_until is not None:
                    response_str = _(
                        'The token %(token)s expired at '
                        '%(valid_until)s.'
                    ) % {
                        'token': token,
                        'valid_until': valid_until
                    }
                else:
                    response_str = _(
                        'The token %(token)s has expired.'
                    ) % {'token': token}
                   
                return HttpResponseGone(response_str)
            else:
                return render(
                    self.request, gone_template_name, status=410
                )
        else:
            raise Http404('Malformed token')

    @classmethod
    def enforce_token(cls, view_func=None, view_instance=None, **kwargs):
        """
        Decorator that validates the ``token`` URL parameter.
        If the token is malformed, the wrapped view raises ``404``.
        If the token has expired, a ``410`` response is returned.
        If the token is valid, the view is executed normally.
        You can control what extra information is passed to the view via kwargs.
        """
        def decorator(_view_func):
            @wraps(_view_func)
            def _wrapped_view(request, *view_args, **view_kwargs):
                # construct the validator instance
                validator = cls(
                    request=request, view_args=view_args, 
                    view_kwargs=view_kwargs,
                    view_instance=view_instance
                )
                return validator.handle_token(
                    _view_func, **kwargs
                )
            return _wrapped_view

        if view_func is None:
            # called with arguments, so we should return a decorator
            return decorator
        elif callable(view_func):
            # called without arguments, so we *are* the decorator
            return decorator(view_func)
        else:
            raise ValueError('Invalid arguments for enforce_token')
    
    # TODO: put examples from lukweb in docs
    @classmethod
    def as_mixin(cls, **mixin_kwargs):
        """
        Returns a view mixin that takes care of token enforcement.
        All kwargs are passed to the :dec:`enforce_token` decorator, and we 
        use some voodoo to pass the view instance as well.
        Unless forced otherwise, this also sets the valid_until and 
        token attributes on the view class.
        """
        # since we control the class here, we can safely
        # default these to yes
        decorator_kwargs = {
            'pass_valid_until': True,
            'pass_token': True,
        }
        decorator_kwargs.update(mixin_kwargs)

        class Mixin(View):
            def dispatch(self, *view_args, **view_kwargs):
                def _dispatch(*args, valid_until=None, token=None, **kwargs):
                    self.valid_until = valid_until
                    self.token = token
                    # python MRO magic takes care of the rest
                    return super(Mixin, self).dispatch(*args, **kwargs)
                # pass the view instance too
                wrapped_view = cls.enforce_token(
                    _dispatch, view_instance=self, **decorator_kwargs
                )
                return wrapped_view(*view_args, **view_kwargs)

        return Mixin
    
    def __init__(self, request, view_args=None, view_kwargs=None,
                 view_instance=None, **kwargs):
        self.request = request
        self.view_args = view_args
        self.view_kwargs = view_kwargs
        # only relevant for class-based views
        self.view_instance = view_instance
        super().__init__(**kwargs)


class TimeBasedRequestTokenValidator(
        TimeBasedTokenValidator,
        RequestTokenValidator,
        abc.ABC):

    def get_generator(self):
        """
        Fetch the generator to obtain tokens from.
        The default implementation requires that either
        ``self.generator`` or ``self.generator_class``
        be defined.

        If ``self.generator`` is specified, the value of this
        instance attribute is used.
        If not, this method looks for ``self.generator_class``
        and attempts to call its :func:`from_view_data` method.

        By default, subclasses of :class:`TimeBasedTokenGenerator`
        make sure that their respective `validator` class attributes
        come with the right fields to make this work out of the box.

        :rtype: TimeBasedTokenGenerator
        """
        generator = super().get_generator()
        if generator is not None:
            return generator

        gen_class = self.generator_class

        return gen_class.from_view_data(
            self.request, self.view_args, self.view_kwargs,
            self.view_instance
        )


class UrlTokenValidator(RequestTokenValidator, abc.ABC):

    def get_token(self):
        return self.view_kwargs['token']


class SessionTokenValidator(RequestTokenValidator, abc.ABC):

    def get_token(self):
        try:
            session_key = self.generator_class.session_key
        except AttributeError:
            raise TypeError(
                'Generators using SessionTokenValidator '
                'must define a session_key attribute.'
            )
        token = self.request.session[session_key]
        # consume the token if necessary
        try:
            if self.generator_class.consume_token:
                del self.request.session[session_key]
        except AttributeError:
            pass
        return token


class DBUrlTokenValidator(UrlTokenValidator, abc.ABC):
    """
    Validate tokens on views that render single objects.
    """

    def get_object(self):
        try:
            return self.object
        except AttributeError:
            if not isinstance(self.view_instance, SingleObjectMixin):
                raise ValueError(
                    'DBUrlTokenValidator requires SingleObjectMixin views'
                )

            # retrieve object from view and cache it
            obj = self.view_instance.get_object()

            def get_cached_object(**_kwargs):
                return obj

            self.view_instance.get_object = get_cached_object
            self.object = obj
            return self.object


class TimeBasedUrlTokenValidator(
        UrlTokenValidator,
        TimeBasedRequestTokenValidator):
    pass


class TimeBasedSessionTokenValidator(
        SessionTokenValidator,
        TimeBasedRequestTokenValidator):
    pass_token = False


class TimeBasedUrlTokenGenerator(
        TimeBasedTokenGenerator,
        validator_base=TimeBasedUrlTokenValidator):
    pass


class TimeBasedSessionTokenGenerator(
        TimeBasedTokenGenerator,
        validator_base=TimeBasedSessionTokenValidator):

    consume_token = True
    
    @classmethod
    def from_view_data(cls, request, *_args, **_kwargs):
        return cls(request)

    def __init__(self, request):
        self.request = request

    def get_session_key(self):
        try:
            return self.session_key
        except AttributeError:
            raise NotImplemented

    def embed_token(self):
        # The token is session-bound, so this makes sense.
        # also, this avoids leaking the token through the URL
        req = self.request
        req.session[self.get_session_key()] = self.bare_token()


class TimeBasedDBUrlTokenValidator(
        DBUrlTokenValidator, TimeBasedTokenValidator):

    def get_generator(self):
        # instantiate a generator using the object we have
        return self.generator_class(self.get_object())


class ObjectDBUrlTokenValidator(DBUrlTokenValidator, ObjectTokenValidator):
    pass


class TimeBasedDBUrlTokenGenerator(
        TimeBasedTokenGenerator,
        validator_base=TimeBasedDBUrlTokenValidator):
    pass


class AccountTokenHandler(TimeBasedTokenGenerator, TimeBasedTokenValidator):
    """
    Essentially reimplements the functionality of 
    :class:`django.contrib.auth.tokens.PasswordResetTokenGenerator` in
    our framework.
    """

    def __init__(self, user):
        self.user = user
        self.generator = self

    # for compatibility with Django's pw reset interface
    @classmethod
    def check_token(cls, user, token):
        return cls(user).validate_token(token)

    def extra_hash_data(self):
        user = self.user
        login_timestamp = '' if user.last_login is None else (
            user.last_login.replace(microsecond=0, tzinfo=None)
        )
        return ''.join([
            str(user.pk), user.password, str(login_timestamp), 
            str(user.is_active)
        ])

    def get_lifespan(self):
        return settings.PASSWORD_RESET_TIMEOUT_DAYS * 24


class PasswordResetTokenGenerator(AccountTokenHandler):
    pass


class UnlockTokenGenerator(AccountTokenHandler):
    pass


class ActivationTokenGenerator(AccountTokenHandler):
    pass


class PasswordConfirmationTokenGenerator(TimeBasedSessionTokenGenerator):

    session_key = 'pwconfirmationtoken'

    def extra_hash_data(self):
        user = self.request.user
        return ''.join([
            # explicitly include the session key
            # to mitigate the possibility of replay attacks
            # TODO: does this actually do anything, and
            # does it depend on the session engine used?
            # Probably fairly useless with cookie-backed sessions,
            # unless they are on a timer.
            str(self.request.session.session_key),
            str(user.last_login),
            str(user.pk),
            str(user.password),
        ])

    def get_lifespan(self):
        # TODO: something like 15 minutes would be more reasonable,
        # but then we need to override more methods in TBT.
        # Regardless, the token is session-bound, so it will expire
        # along with the session.
        return 1
